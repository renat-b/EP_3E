#pragma once
#include "stdint.h"

#pragma pack(push, 1)
struct DR7BaseHeader
{
    uint8_t  DevName[6];   // – название прибора(обычно EMP - 3E)
    uint16_t DevNum;       // – серийный номер
    uint8_t  DevVer;       // – версия прошивки(Vh * 10 + Vl)
    uint8_t  DevRel;       // – релиз прошивки
    uint32_t StartTime;    // – время начала записи в секундах от 1.1.1970
    uint16_t MeasNum;      // – номер файла, увеличивается после каждого создания файла
};
#pragma pack(pop)

#pragma pack(push, 1)
struct uint24_t
{
    uint8_t   data[3];
    // 
    uint32_t  Get() const
    {
        uint32_t val = 0;
        memcpy(&val, &data[0], sizeof(data));
        return val;
    }
};
#pragma pack(pop)


struct SComInner3E
{
    uint8_t   Cn1: 3;       // адрес канала первого мультиплексированного АЦП
    uint8_t   Cn2: 3;       // адрес канала второго мультиплексированного АЦП
    uint8_t   Cg0: 1;       // требование установки адреса первого мультиплексора 
    uint8_t   Cg1: 1;       // требование установки адреса второго мультиплексора
};

struct MaskInner3E
{
    uint8_t   reserved: 1;  // Резерв
    uint8_t   Rn0: 1;       // Запуск АЦП канала 0 (18 - разрядный АЦП датчика 0)
    uint8_t   Rn1: 1;       // Запуск АЦП канала 1 (16 - разрядный АЦП датчика 0)
    uint8_t   Rn2: 1;	    // Запуск АЦП канала 2 (18 - разрядный АЦП датчика 1)
    uint8_t   Rn3: 1;	    // Запуск АЦП канала 3 (16 - разрядный АЦП датчика 1)
    uint8_t   Rn4: 1;	    // Запуск АЦП первого мультиплексированного канала
    uint8_t   Rn5: 1;	    // Запуск АЦП второго мультиплексированного канала
};


enum ScaleVariantInner3E : uint8_t 
{
    ScVarType0 = 0,   // измерение единичной точки сигналов с количеством накоплений, заданном в NPnt;
    ScVarType1 = 1,   // измерение спада в логарифмической шкале с плотностью точек 16 точек на декаду с максимальным количеством накоплений;
    ScVarType2 = 2,   // то же, но количество накоплений на длинных временах кратно 20 мс – периоду частоты 50 Гц для обеспечения максимального подавления помех с частотой сети;
    ScVarType3 = 3,   // то же, кратно периоду частоты 60 Гц;
    ScVarType4 = 4,   // логарифмическая шкала 32 точки на декаду с максимальным накоплением;
    ScVarType5 = 5,   // то же для подавления 50 Гц;
    ScVarType6 = 6,   // то же для подавления 60 Гц;
    ScVarType7 = 7,   // равномерная шкала с заданным шагом
};

#pragma pack(push, 1)
struct BeginPointInner3E
{
    uint8_t   data;
    uint8_t   reserved;
    //
    uint32_t  Get() const
    {
        return data;
    }
};
#pragma pack(pop)

struct NumPointInner3E
{
    uint16_t  data;
    //
    uint32_t  Get() const
    {
        return data;
    }
};

// Операция измерения
#pragma pack(push, 1)
struct OperationMeasure3E
{
    uint24_t ofs;        // смещение начала операции относительно начала сценария в единицах 0.01 мс
    SComInner3E     scom;       // управление коммутацией коммутируемых каналов
    MaskInner3E     mask;       // выбор запускаемых в операции АЦП 
    ScaleVariantInner3E    sc_var;     // вариант шкалы измерения 
    BeginPointInner3E   b_point;    // номер начальной точки шкалы для логарифмических шкал (1-6) или выбор шага для равномерной шкалы (7), используется только младший байт (2)
    NumPointInner3E     n_point;    // количество регистрируемых точек спада для шкал 1-7 или количество накоплений точки для варианта 0 
};
#pragma pack(pop)


// включаемое в этот момент состояние сигналов управления
#pragma pack(push, 1)
struct ControlInner3E
{
    uint8_t ShD0: 1;	// Включение преобразователя канала 0	RA0, XS40
    uint8_t ShD1: 1;	// Включение преобразователя канала 1	RA1, XS42
    uint8_t Pul0: 1;	// Включение импульса канала 0	        RA2, XS43
    uint8_t Pol0: 1;	// Полярность импульса канала 0         RA3, XS44
    uint8_t Pul1: 1;	// Включение импульса канала 1          RA4, XS45
    uint8_t Pol1: 1;	// Полярность импульса канала 1         RA5, XS46
    uint8_t RqD0: 1;	// Требование установки ЦАП0
    uint8_t RqD1: 1;	// Требование установки ЦАП1
};
#pragma pack(pop)

// Операция возбуждения 
#pragma pack(push, 1)
struct OperationImpulse3E
{
    uint24_t   ofs;       // смещение операции относительно начала сценария в единицах 0.01 мс
    ControlInner3E  ctrl; // включаемое состояние сигналов управления
    uint16_t   dac0;      // задаваемый ток возбуждения датчика VS в единицах 0.1 мА
    uint16_t   dac1;      // задаваемый ток возбуждения датчика SS в единицах 0.1 мА
};
#pragma pack(pop)

// интервал включает следующие параметры
#pragma pack(push, 1)
struct IntervalInner3E
{
    uint24_t   ScrTim;      // – длительность цикла в единицах 0.01 мс
    uint24_t   Pause;       // – длительность паузы перед циклами измерений – количество ScrTim
    uint24_t   Cycles;      // – задаваемое количество циклов измерения
    uint24_t   CycCnt;      // – фактическое количество циклов(при записи циклограммы = 0, в файле DR7 соответствует фактическому количеству данных цикла для этого интервала)
};
#pragma pack(pop)

#pragma pack(push, 1)
struct DR7SampleHeader
{
    uint24_t  cyclo_pos;    // Индекс цикла – число, передаваемое при запуске сценария командами MeasDev или Measure или командой синхронизации Sync.В автоматическом или циклическом режиме без синхронизации соответствует текущему счетчику циклов после изменения интервала.
    uint8_t   interval_pos; // Номер интервала
    uint32_t  time;         // Время в миллисекундах относительно времени запуска StartTime
};
#pragma pack(pop)